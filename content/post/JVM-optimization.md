---
title: "JVM Optimization"
date: 2019-05-20
tags: ["JVM","Java"]
draft: false
---

## JVM Architecture

![](/img/jvm-3.jpg)

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).

Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java enabled system without any adjustment. This is all possible because of JVM.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

### Class Loader Subsystem

It is mainly responsible for three activities.

- Loading
- Linking
- Initialization

**Loading :** The Class loader reads the .class file, generate the corresponding binary data and save it in method area. For each .class file, JVM stores following information in method area.

- Fully qualified name of the loaded class and its immediate parent class.
- Whether .class file is related to Class or Interface or Enum
- Modifier, Variables and Method information etc.

Code reference is below:

    // A Java program to demonstrate working of a Class type 
    // object created by JVM to represent .class file in 
    // memory. 
    import java.lang.reflect.Field; 
    import java.lang.reflect.Method; 

    // Java code to demonstrate use of Class object 
    // created by JVM 
    public class Test 
    { 
    public static void main(String[] args) 
    { 
        Student s1 = new Student(); 

        // Getting hold of Class object created 
        // by JVM. 
        Class c1 = s1.getClass(); 

        // Printing type of object using c1. 
        System.out.println(c1.getName()); 

        // getting all methods in an array 
        Method m[] = c1.getDeclaredMethods(); 
        for (Method method : m) 
            System.out.println(method.getName()); 

        // getting all fields in an array 
        Field f[] = c1.getDeclaredFields(); 
        for (Field field : f) 
            System.out.println(field.getName()); 
            } 
    }   

    // A sample class whose information is fetched above using 
    // its Class object. 
    class Student 
    { 
    private String name; 
    private int roll_No; 

    public String getName() { return name; } 
    public void setName(String name) { this.name = name; } 
    public int getRoll_no() { return roll_No; } 
    public void setRoll_no(int roll_no) { 
        this.roll_No = roll_no; 
            } 
        } 

**Linking :** Performs verification, preparation, and (optionally) resolution.

- Verification : It ensures the correctness of .class file i.e. it check whether this file is properly formatted and generated by valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError.
- Preparation : JVM allocates memory for class variables and initializing the memory to default values.
- Resolution : It is the process of replacing symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity.

**Initialization :** In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in class hierarchy.
In general, there are three class loaders :

- Bootstrap class loader : Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes. It loads core java API classes present in JAVA_HOME/jre/lib directory. This path is popularly known as bootstrap path. It is implemented in native languages like C, C++.
- Extension class loader : It is child of bootstrap class loader. It loads the classes present in the extensions directories JAVA_HOME/jre/lib/ext(Extension path) or any other directory specified by the java.ext.dirs system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.
- System/Application class loader : It is child of extension class loader. It is responsible to load classes from application class path. It internally uses Environment Variable which mapped to java.class.path. It is also implemented in Java by the sun.misc.Launcher$AppClassLoader class.

Example code is below:


    // Java code to demonstrate Class Loader subsystem 
    public class Test 
    { 
        public static void main(String[] args) 
        { 
            // String class is loaded by bootstrap loader, and 
            // bootstrap loader is not Java object, hence null 
            System.out.println(String.class.getClassLoader()); 

            // Test class is loaded by Application loader 
            System.out.println(Test.class.getClassLoader()); 
        } 
    }	 

![](/img/jvmclassloader.jpg)

### JVM Memory

**Method area :** In method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource.

**Heap area :** Information of all objects is stored in heap area. There is also one Heap Area per JVM. It is also a shared resource.

**Stack area :** For every thread, JVM create one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which store methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminate, itâ€™s run-time stack will be destroyed by JVM. It is not a shared resource.

**PC Registers :** Store address of current execution instruction of a thread. Obviously each thread has separate PC Registers.

**Native method stacks :** For every thread, separate native stack is created. It stores native method information.

![](/img/jvm-memory-2.jpg)

### Execution Engine
Execution engine execute the .class (bytecode). It reads the byte-code line by line, use data and information present in various memory area and execute instructions. It can be classified in three parts :-

- Interpreter : It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
- Just-In-Time Compiler(JIT) : It is used to increase efficiency of interpreter.It compiles the entire bytecode and changes it to native code so whenever interpreter see repeated method calls,JIT provide direct native code for that part so re-interpretation is not required,thus efficiency is improved.
- Garbage Collector : It destroy un-referenced objects.For more on Garbage Collector,refer Garbage Collector.

## Why is Java both Interpreted and Compiled Language?
Programming languages are classified as
- Higher Level Language Ex. C++, Java
Middle-Level Languages Ex. C
- Low-Level Language Ex Assembly
- finally the lowest level as the Machine Language.
A compiler is a program which converts a program from one level of language to another. Example conversion of C++ program into machine code.

The java compiler converts high-level java code into bytecode (which is also a type of machine code).

An interpreter is a program which converts a program at one level to another programming language at the same level. Example conversion of Java program into C++

In Java, the Just In Time Code generator converts the bytecode into the native machine code which are at the same programming levels.

Hence, Java is both compiled as well as interpreted language.

### Why is Java slow?
The two main reasons behind the slowness of Java are

1. Dynamic Linking: Unlike C, linking is done at run-time, every time the program is run in Java.
2. Run-time Interpreter: The conversion of byte code into native machine code is done at run-time in Java which furthers slows down the speed
However, the latest version of Java has addressed the performance bottlenecks to a great extent.

Summary:

- JVM or Java Virtual Machine is the engine that drives the Java Code. It converts Java bytecode into machines language.
- In JVM, Java code is compiled to bytecode. This bytecode gets interpreted on different machines
- JIT or Just-in-time compiler is the part of the Java Virtual Machine (JVM). It is used to speed up the execution time
- In comparison to other compiler machines, Java may be slow in execution.
